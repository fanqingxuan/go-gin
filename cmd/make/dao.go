package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"

	"go-gin/config"
	"go-gin/internal/component/db"

	_ "github.com/go-sql-driver/mysql"
)

const (
	entityDir      = "model/entity"
	doDir          = "model/do"
	daoDir         = "model/dao"
	daoInternalDir = "model/dao/internal"
)

const entityTmpl = `// Code generated by cmd/make. DO NOT EDIT.
package entity

import (
{{range .Imports}}	"{{.}}"
{{end}})

type {{.StructName}} struct {
{{range .Fields}}	{{.Name}} {{.Type}} {{.Tag}}
{{end}}}

func (e *{{.StructName}}) TableName() string {
	return "{{.TableName}}"
}
`

const doTmpl = `// Code generated by cmd/make. DO NOT EDIT.
package do

// {{.StructName}} is the golang structure of table {{.TableName}} for DAO operations like Where/Data.
type {{.StructName}} struct {
{{range .Fields}}	{{.Name}} any {{if .Comment}}// {{.Comment}}{{end}}
{{end}}}
`

const daoInternalTmpl = `// Code generated by cmd/make. DO NOT EDIT.
package internal

import (
	"context"
	"go-gin/internal/component/db"
)

type {{.StructName}}Dao struct {
	table      string
	primaryKey string
	columns    {{.StructName}}Columns
}

type {{.StructName}}Columns struct {
{{range .Fields}}	{{.Name}} string
{{end}}}

var {{.VarName}}Columns = {{.StructName}}Columns{
{{range .Fields}}	{{.Name}}: "{{.ColumnName}}",
{{end}}}

func New{{.StructName}}Dao() *{{.StructName}}Dao {
	return &{{.StructName}}Dao{
		table:      "{{.TableName}}",
		primaryKey: "{{.PrimaryKey}}",
		columns:    {{.VarName}}Columns,
	}
}

func (d *{{.StructName}}Dao) Table() string {
	return d.table
}

func (d *{{.StructName}}Dao) PrimaryKey() string {
	return d.primaryKey
}

func (d *{{.StructName}}Dao) Columns() {{.StructName}}Columns {
	return d.columns
}

func (d *{{.StructName}}Dao) Ctx(ctx context.Context) *db.Model {
	return db.NewModel(ctx, d.table).SetPrimaryKey(d.primaryKey)
}

func (d *{{.StructName}}Dao) Transaction(ctx context.Context, f func(ctx context.Context, tx *db.TX) error) error {
	return db.Transaction(ctx, func(tx *db.TX) error {
		return f(ctx, tx)
	})
}
`

const daoTmpl = `// Code generated by cmd/make. You may modify this file.
package dao

import (
	"go-gin/model/dao/internal"
)

type {{.VarName}}Dao struct {
	*internal.{{.StructName}}Dao
}

var {{.StructName}} = &{{.VarName}}Dao{internal.New{{.StructName}}Dao()}

// Add your custom methods below.
`

type TableInfo struct {
	StructName string
	VarName    string
	TableName  string
	PrimaryKey string
	Fields     []FieldInfo
	Imports    []string
}

type FieldInfo struct {
	Name       string
	ColumnName string
	Type       string
	Tag        string
	Comment    string
}

type ColumnInfo struct {
	ColumnName    string  `gorm:"column:COLUMN_NAME"`
	DataType      string  `gorm:"column:DATA_TYPE"`
	IsNullable    string  `gorm:"column:IS_NULLABLE"`
	ColumnKey     string  `gorm:"column:COLUMN_KEY"`
	ColumnComment string  `gorm:"column:COLUMN_COMMENT"`
	Extra         string  `gorm:"column:EXTRA"`
	ColumnDefault *string `gorm:"column:COLUMN_DEFAULT"`
}

func runDao(args []string) {
	fs := flag.NewFlagSet("make:dao", flag.ExitOnError)
	configFile := fs.String("f", "./.env", "配置文件路径")
	tables := fs.String("t", "", "指定表名，多个用逗号分隔")
	fs.Parse(args)

	config.Init(*configFile)
	dbConf := config.GetDbConf()
	dbConf.LogLevel = "silent"
	db.InitConfig(dbConf)
	db.Init()

	var tableList []string
	if *tables != "" {
		for _, t := range strings.Split(*tables, ",") {
			t = strings.TrimSpace(t)
			if t != "" {
				tableList = append(tableList, t)
			}
		}
	} else {
		var err error
		tableList, err = getTables()
		if err != nil {
			fmt.Fprintf(os.Stderr, "获取表列表失败: %v\n", err)
			os.Exit(1)
		}
	}

	if len(tableList) == 0 {
		fmt.Println("未找到任何表")
		return
	}

	for _, dir := range []string{entityDir, doDir, daoDir, daoInternalDir} {
		if err := os.MkdirAll(dir, 0755); err != nil {
			fmt.Fprintf(os.Stderr, "创建目录失败: %v\n", err)
			os.Exit(1)
		}
	}

	entityT := template.Must(template.New("entity").Parse(entityTmpl))
	doT := template.Must(template.New("do").Parse(doTmpl))
	daoInternalT := template.Must(template.New("daoInternal").Parse(daoInternalTmpl))
	daoT := template.Must(template.New("dao").Parse(daoTmpl))

	for _, tableName := range tableList {
		tableInfo, err := getTableInfo(tableName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "获取表 %s 信息失败: %v\n", tableName, err)
			continue
		}

		if err := generateFile(entityT, fmt.Sprintf("%s/%s.go", entityDir, tableName), tableInfo); err != nil {
			fmt.Fprintf(os.Stderr, "生成 entity/%s.go 失败: %v\n", tableName, err)
			continue
		}
		fmt.Printf("已生成: %s/%s.go\n", entityDir, tableName)

		if err := generateFile(doT, fmt.Sprintf("%s/%s.go", doDir, tableName), tableInfo); err != nil {
			fmt.Fprintf(os.Stderr, "生成 do/%s.go 失败: %v\n", tableName, err)
			continue
		}
		fmt.Printf("已生成: %s/%s.go\n", doDir, tableName)

		if err := generateFile(daoInternalT, fmt.Sprintf("%s/%s.go", daoInternalDir, tableName), tableInfo); err != nil {
			fmt.Fprintf(os.Stderr, "生成 dao/internal/%s.go 失败: %v\n", tableName, err)
			continue
		}
		fmt.Printf("已生成: %s/%s.go\n", daoInternalDir, tableName)

		daoFile := fmt.Sprintf("%s/%s.go", daoDir, tableName)
		if _, err := os.Stat(daoFile); os.IsNotExist(err) {
			if err := generateFile(daoT, daoFile, tableInfo); err != nil {
				fmt.Fprintf(os.Stderr, "生成 dao/%s.go 失败: %v\n", tableName, err)
				continue
			}
			fmt.Printf("已生成: %s\n", daoFile)
		} else {
			fmt.Printf("跳过: %s (已存在)\n", daoFile)
		}
	}

	fmt.Printf("\n共处理 %d 个表\n", len(tableList))
}

func generateFile(t *template.Template, fileName string, data *TableInfo) error {
	f, err := os.Create(fileName)
	if err != nil {
		return err
	}
	defer f.Close()
	return t.Execute(f, data)
}

func getTables() ([]string, error) {
	var tables []string
	err := db.WithContext(context.Background()).Raw("SHOW TABLES").Scan(&tables).Error()
	return tables, err
}

func getTableInfo(tableName string) (*TableInfo, error) {
	var columns []ColumnInfo
	sql := `SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_KEY, COLUMN_COMMENT, EXTRA, COLUMN_DEFAULT
			FROM information_schema.COLUMNS
			WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = ?
			ORDER BY ORDINAL_POSITION`

	if err := db.WithContext(context.Background()).Raw(sql, tableName).Scan(&columns).Error(); err != nil {
		return nil, err
	}

	structName := toPascalCase(tableName)
	info := &TableInfo{
		StructName: structName,
		VarName:    toLowerFirst(structName),
		TableName:  tableName,
		PrimaryKey: "id",
		Fields:     make([]FieldInfo, 0, len(columns)),
	}

	importSet := make(map[string]bool)

	for _, col := range columns {
		field := FieldInfo{
			Name:       toPascalCase(col.ColumnName),
			ColumnName: col.ColumnName,
			Type:       mysqlTypeToGoType(col.DataType, col.IsNullable == "YES"),
			Tag:        buildTag(col),
			Comment:    col.ColumnComment,
		}

		if strings.Contains(field.Type, "time.Time") {
			importSet["time"] = true
		}

		if col.ColumnKey == "PRI" {
			info.PrimaryKey = col.ColumnName
		}

		info.Fields = append(info.Fields, field)
	}

	for imp := range importSet {
		info.Imports = append(info.Imports, imp)
	}

	return info, nil
}

func mysqlTypeToGoType(mysqlType string, nullable bool) string {
	var goType string

	switch strings.ToLower(mysqlType) {
	case "tinyint", "smallint", "mediumint", "int", "integer":
		goType = "int"
	case "bigint":
		goType = "int64"
	case "float":
		goType = "float32"
	case "double", "decimal", "numeric":
		goType = "float64"
	case "char", "varchar", "text", "tinytext", "mediumtext", "longtext", "enum", "set":
		goType = "string"
	case "date", "datetime", "timestamp", "time":
		goType = "time.Time"
	case "blob", "tinyblob", "mediumblob", "longblob", "binary", "varbinary":
		goType = "[]byte"
	case "json":
		goType = "string"
	case "bit", "bool", "boolean":
		goType = "bool"
	default:
		goType = "string"
	}

	if nullable && goType != "[]byte" && goType != "string" {
		return "*" + goType
	}

	return goType
}

func buildTag(col ColumnInfo) string {
	var parts []string

	gormParts := []string{fmt.Sprintf("column:%s", col.ColumnName)}
	if col.ColumnKey == "PRI" {
		gormParts = append(gormParts, "primaryKey")
	}
	if col.Extra == "auto_increment" {
		gormParts = append(gormParts, "autoIncrement")
	}
	parts = append(parts, fmt.Sprintf(`gorm:"%s"`, strings.Join(gormParts, ";")))
	parts = append(parts, fmt.Sprintf(`json:"%s"`, col.ColumnName))

	return "`" + strings.Join(parts, " ") + "`"
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func toLowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}
