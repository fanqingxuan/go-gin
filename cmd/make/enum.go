package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const enumScanDir = "const/enum"

const enumTmpl = `// Code generated by cmd/make. DO NOT EDIT.
package {{.Package}}

import (
	"database/sql/driver"
	"encoding/json"
	"go-gin/internal/etype"
)

func (s *{{.Type}}) Scan(value any) error {
	parsed, err := etype.ScanEnum[{{.Type}}](value)
	if err != nil {
		return err
	}
	if parsed != nil {
		*s = *parsed
	}
	return nil
}

func (s *{{.Type}}) Value() (driver.Value, error) {
	return s.BaseEnum.Value()
}

func (s *{{.Type}}) UnmarshalJSON(data []byte) error {
	parsed, err := etype.UnmarshalEnum[{{.Type}}](data)
	if err != nil {
		return err
	}
	if parsed != nil {
		*s = *parsed
	}
	return nil
}

func (s *{{.Type}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Code())
}
`

type enumInfo struct {
	Type    string
	Package string
	Dir     string
}

func runEnum() {
	enums, err := findEnumTypes(enumScanDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "扫描枚举类型失败: %v\n", err)
		os.Exit(1)
	}

	if len(enums) == 0 {
		fmt.Println("未找到枚举类型")
		return
	}

	t := template.Must(template.New("enum").Parse(enumTmpl))

	for _, e := range enums {
		fileName := filepath.Join(e.Dir, "gen_"+toSnakeCase(e.Type)+".go")

		f, err := os.Create(fileName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "创建文件 %s 失败: %v\n", fileName, err)
			continue
		}

		if err := t.Execute(f, e); err != nil {
			fmt.Fprintf(os.Stderr, "生成 %s 代码失败: %v\n", e.Type, err)
			f.Close()
			continue
		}
		f.Close()

		fmt.Printf("已生成: %s\n", fileName)
	}

	fmt.Printf("\n共生成 %d 个枚举文件\n", len(enums))
}

func findEnumTypes(dir string) ([]enumInfo, error) {
	var enums []enumInfo
	fset := token.NewFileSet()

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}
		if strings.HasPrefix(filepath.Base(path), "gen_") {
			return nil
		}

		file, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			return fmt.Errorf("解析 %s 失败: %w", path, err)
		}

		pkgName := file.Name.Name
		fileDir := filepath.Dir(path)

		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				if hasBaseEnum(structType) {
					enums = append(enums, enumInfo{
						Type:    typeSpec.Name.Name,
						Package: pkgName,
						Dir:     fileDir,
					})
				}
			}
		}

		return nil
	})

	return enums, err
}

func hasBaseEnum(s *ast.StructType) bool {
	for _, field := range s.Fields.List {
		if len(field.Names) > 0 {
			continue
		}
		if t, ok := field.Type.(*ast.SelectorExpr); ok {
			if ident, ok := t.X.(*ast.Ident); ok {
				if ident.Name == "etype" && t.Sel.Name == "BaseEnum" {
					return true
				}
			}
		}
	}
	return false
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
