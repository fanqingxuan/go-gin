// Entity 代码生成器
// 用法: go run cmd/entity/main.go -f .env
//       go run cmd/entity/main.go -f .env -t user,order,product
// 自动扫描数据库所有表，生成对应的 entity 文件到 model/entity 目录
package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"

	"go-gin/config"
	"go-gin/internal/component/db"

	_ "github.com/go-sql-driver/mysql"
)

var configFile = flag.String("f", "./.env", "the config file")
var tables = flag.String("t", "", "指定要生成的表名，多个表用逗号分隔，为空则生成所有表")

const outputDir = "model/entity"

const entityTmpl = `// Code generated by cmd/entity. DO NOT EDIT.
package entity

import (
	"go-gin/internal/entityx"
{{range .Imports}}	"{{.}}"
{{end}})

type {{.StructName}} struct {
	entityx.BaseEntity
{{range .Fields}}	{{.Name}} {{.Type}} {{.Tag}}
{{end}}}

func (e *{{.StructName}}) TableName() string {
	return "{{.TableName}}"
}
`

type TableInfo struct {
	StructName string
	TableName  string
	Fields     []FieldInfo
	Imports    []string
}

type FieldInfo struct {
	Name string
	Type string
	Tag  string
}

type ColumnInfo struct {
	ColumnName    string  `gorm:"column:COLUMN_NAME"`
	DataType      string  `gorm:"column:DATA_TYPE"`
	IsNullable    string  `gorm:"column:IS_NULLABLE"`
	ColumnKey     string  `gorm:"column:COLUMN_KEY"`
	ColumnComment string  `gorm:"column:COLUMN_COMMENT"`
	Extra         string  `gorm:"column:EXTRA"`
	ColumnDefault *string `gorm:"column:COLUMN_DEFAULT"`
}

func main() {
	flag.Parse()

	config.Init(*configFile)

	dbConf := config.GetDbConf()
	dbConf.LogLevel = "silent"
	db.InitConfig(dbConf)
	db.Init()

	// 获取表名列表
	var tableList []string
	if *tables != "" {
		// 使用指定的表名
		for _, t := range strings.Split(*tables, ",") {
			t = strings.TrimSpace(t)
			if t != "" {
				tableList = append(tableList, t)
			}
		}
	} else {
		// 获取所有表名
		var err error
		tableList, err = getTables()
		if err != nil {
			fmt.Fprintf(os.Stderr, "获取表列表失败: %v\n", err)
			os.Exit(1)
		}
	}

	if len(tableList) == 0 {
		fmt.Println("未找到任何表")
		return
	}

	// 确保输出目录存在
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "创建目录失败: %v\n", err)
		os.Exit(1)
	}

	t := template.Must(template.New("entity").Parse(entityTmpl))

	for _, tableName := range tableList {
		tableInfo, err := getTableInfo(tableName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "获取表 %s 信息失败: %v\n", tableName, err)
			continue
		}

		fileName := fmt.Sprintf("%s/%s.go", outputDir, tableName)
		f, err := os.Create(fileName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "创建文件 %s 失败: %v\n", fileName, err)
			continue
		}

		if err := t.Execute(f, tableInfo); err != nil {
			fmt.Fprintf(os.Stderr, "生成 %s 代码失败: %v\n", tableName, err)
			f.Close()
			continue
		}
		f.Close()

		fmt.Printf("已生成: %s\n", fileName)
	}

	fmt.Printf("\n共生成 %d 个 entity 文件\n", len(tableList))
}

// getTables 获取数据库所有表名
func getTables() ([]string, error) {
	var tables []string
	err := db.WithContext(context.Background()).Raw("SHOW TABLES").Scan(&tables).Error()
	return tables, err
}

// getTableInfo 获取表结构信息
func getTableInfo(tableName string) (*TableInfo, error) {
	var columns []ColumnInfo
	sql := `SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_KEY, COLUMN_COMMENT, EXTRA, COLUMN_DEFAULT
			FROM information_schema.COLUMNS
			WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = ?
			ORDER BY ORDINAL_POSITION`

	if err := db.WithContext(context.Background()).Raw(sql, tableName).Scan(&columns).Error(); err != nil {
		return nil, err
	}

	info := &TableInfo{
		StructName: toPascalCase(tableName),
		TableName:  tableName,
		Fields:     make([]FieldInfo, 0, len(columns)),
	}

	importSet := make(map[string]bool)

	for _, col := range columns {
		field := FieldInfo{
			Name: toPascalCase(col.ColumnName),
			Type: mysqlTypeToGoType(col.DataType, col.IsNullable == "YES"),
			Tag:  buildTag(col),
		}

		// 收集需要的 imports
		if strings.Contains(field.Type, "time.Time") {
			importSet["time"] = true
		}

		info.Fields = append(info.Fields, field)
	}

	for imp := range importSet {
		info.Imports = append(info.Imports, imp)
	}

	return info, nil
}

// mysqlTypeToGoType 将 MySQL 类型转换为 Go 类型
func mysqlTypeToGoType(mysqlType string, nullable bool) string {
	var goType string

	switch strings.ToLower(mysqlType) {
	case "tinyint", "smallint", "mediumint", "int", "integer":
		goType = "int"
	case "bigint":
		goType = "int64"
	case "float":
		goType = "float32"
	case "double", "decimal", "numeric":
		goType = "float64"
	case "char", "varchar", "text", "tinytext", "mediumtext", "longtext", "enum", "set":
		goType = "string"
	case "date", "datetime", "timestamp", "time":
		goType = "time.Time"
	case "blob", "tinyblob", "mediumblob", "longblob", "binary", "varbinary":
		goType = "[]byte"
	case "json":
		goType = "string"
	case "bit", "bool", "boolean":
		goType = "bool"
	default:
		goType = "string"
	}

	if nullable && goType != "[]byte" && goType != "string" {
		return "*" + goType
	}

	return goType
}

// buildTag 构建 struct tag
func buildTag(col ColumnInfo) string {
	var parts []string

	// gorm tag
	gormParts := []string{fmt.Sprintf("column:%s", col.ColumnName)}
	if col.ColumnKey == "PRI" {
		gormParts = append(gormParts, "primaryKey")
	}
	if col.Extra == "auto_increment" {
		gormParts = append(gormParts, "autoIncrement")
	}
	parts = append(parts, fmt.Sprintf(`gorm:"%s"`, strings.Join(gormParts, ";")))

	// json tag
	parts = append(parts, fmt.Sprintf(`json:"%s"`, col.ColumnName))

	return "`" + strings.Join(parts, " ") + "`"
}

// toPascalCase 将下划线命名转为大驼峰
func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
