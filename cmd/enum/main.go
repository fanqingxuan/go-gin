// 枚举代码生成器
// 用法: go run cmd/enum/main.go
// 自动扫描 const/enum 目录下所有嵌入 etype.BaseEnum 的结构体，生成对应的 gen_*.go 文件
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const scanDir = "const/enum"

const tmpl = `// Code generated by cmd/enum. DO NOT EDIT.
package {{.Package}}

import (
	"database/sql/driver"
	"encoding/json"
	"go-gin/internal/etype"
)

func (s *{{.Type}}) Scan(value any) error {
	parsed, err := etype.ScanEnum[{{.Type}}](value)
	if err != nil {
		return err
	}
	if parsed != nil {
		*s = *parsed
	}
	return nil
}

func (s *{{.Type}}) Value() (driver.Value, error) {
	return s.BaseEnum.Value()
}

func (s *{{.Type}}) UnmarshalJSON(data []byte) error {
	parsed, err := etype.UnmarshalEnum[{{.Type}}](data)
	if err != nil {
		return err
	}
	if parsed != nil {
		*s = *parsed
	}
	return nil
}

func (s *{{.Type}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.Code())
}
`

type enumInfo struct {
	Type    string
	Package string
	Dir     string
}

func main() {
	// 查找所有枚举类型
	enums, err := findEnumTypes(scanDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "扫描枚举类型失败: %v\n", err)
		os.Exit(1)
	}

	if len(enums) == 0 {
		fmt.Println("未找到枚举类型")
		return
	}

	// 生成代码
	t := template.Must(template.New("enum").Parse(tmpl))

	for _, e := range enums {
		fileName := filepath.Join(e.Dir, "gen_"+toSnakeCase(e.Type)+".go")

		f, err := os.Create(fileName)
		if err != nil {
			fmt.Fprintf(os.Stderr, "创建文件 %s 失败: %v\n", fileName, err)
			continue
		}

		if err := t.Execute(f, e); err != nil {
			fmt.Fprintf(os.Stderr, "生成 %s 代码失败: %v\n", e.Type, err)
			f.Close()
			continue
		}
		f.Close()

		fmt.Printf("已生成: %s\n", fileName)
	}

	fmt.Printf("\n共生成 %d 个枚举文件\n", len(enums))
}

// findEnumTypes 扫描目录及子目录，查找所有嵌入 etype.BaseEnum 的结构体
func findEnumTypes(dir string) ([]enumInfo, error) {
	var enums []enumInfo

	fset := token.NewFileSet()

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// 跳过目录和非 .go 文件
		if info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		// 跳过生成的文件
		if strings.HasPrefix(filepath.Base(path), "gen_") {
			return nil
		}

		// 解析 Go 文件
		file, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			return fmt.Errorf("解析 %s 失败: %w", path, err)
		}

		// 获取包名和目录
		pkgName := file.Name.Name
		fileDir := filepath.Dir(path)

		// 遍历声明，查找结构体
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				// 检查是否嵌入了 etype.BaseEnum
				if hasBaseEnum(structType) {
					enums = append(enums, enumInfo{
						Type:    typeSpec.Name.Name,
						Package: pkgName,
						Dir:     fileDir,
					})
				}
			}
		}

		return nil
	})

	return enums, err
}

// hasBaseEnum 检查结构体是否嵌入了 etype.BaseEnum
func hasBaseEnum(s *ast.StructType) bool {
	for _, field := range s.Fields.List {
		// 嵌入字段没有名称
		if len(field.Names) > 0 {
			continue
		}

		switch t := field.Type.(type) {
		case *ast.SelectorExpr:
			// etype.BaseEnum
			if ident, ok := t.X.(*ast.Ident); ok {
				if ident.Name == "etype" && t.Sel.Name == "BaseEnum" {
					return true
				}
			}
		}
	}
	return false
}

// toSnakeCase 驼峰转下划线
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
